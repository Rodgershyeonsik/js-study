<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>promise chaining</title>
    </head>
    <body>

    </body>
        <script>
            // promise chaining 예시
            new Promise(function(resolve, reject) {
                setTimeout(() => resolve(1), 1000); // 1초 후 최초 프라미스 이행
            }).then(function(result) { // 첫번째 .then 핸들러 호출
                alert(result); // 1
                return result * 2; 
            }).then(function(result) { // 첫번째 .then 핸들러의 반환값 전달
                alert(result); // 2
                return result * 2;
            }).then(function(result) { // 두번째 .then 핸들러의 반환값 전달
                alert(result); // 4
                return result * 2;
            });

            // 이런 체이닝이 가능한 이유는 promise.then을 호출하면 promise가 반환되기 때문
            // 한편 핸들러가 값을 반환할 땐 promise의 result가 되어 다음 then은 이 값을 이용해 호출됨

            // promise chaining이 아닌 경우 예시
            // 이 핸들러들은 result를 순차적으로 전달하지 않고 독립적으로 처리함
            // 이렇게 쓰는 경우는 거의 없고, 주로 chaining을 해서 쓴다
            let promise = new Promise(function(resolve, reject) {
                setTimeout(() => resolve(1), 1000);
            });

            promise.then(function(result) {
                alert(result); // 1
                return result * 2;
            });

            promise.then(function(result) {
                alert(result); // 1
                return result * 2;
            });

            promise.then(function(result) {
                alert(result); // 1
                return result * 2;
            });

            // .then(handler)의 handler가 promise를 반환하는 예제
            // handler가 promise가 처리될 때까지 기다리기 때문에 비동기 작업을 순차저으로 연결 가능
            new Promise(function(resolve, reject) {
                
                setTimeout(() => resolve(1), 1000);

            }).then(function(result) {
                
                alert(result); // 1

                return new Promise(function(resolve, reject) {
                    setTimeout(() => resolve(result * 2), 1000);
                });

            }).then(function(result) {
                alert(result); // 2

                return new Promise(function(resolve, reject) {
                    setTimeout(() => resolve(result * 2), 1000);
                })

            }).then(function(result) {

                alert(result); // 4

            });

            // 비동기 동작은 항상 promise를 반환하도록 하는 것이 좋음
            // 당장 체인 확장 계획이 없더라도, 나중에 필요한 경우 손쉽게 확장이 가능함
        </script>
</html>